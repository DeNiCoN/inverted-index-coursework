use futures::{executor::block_on, future, prelude::*};
use inverted_index_coursework::{
    rpc::InvertedIndexService, simple_inverted_index::MultiFileThreadedSimpleInvertedIndex,
    InvertedIndex,
};
use std::{
    net::{IpAddr, Ipv6Addr, SocketAddr},
    path::PathBuf,
    sync::Arc,
    time::Duration,
};
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use tokio::{sync::RwLock, time};

#[derive(Clone)]
struct Server<T: InvertedIndex> {
    inverted_index_lock: Arc<RwLock<T>>,
}

impl<T: InvertedIndex> Server<T> {
    fn new() -> Self {
        Self {
            inverted_index_lock: Arc::new(RwLock::new(T::new())),
        }
    }
}

#[tarpc::server]
impl<T: InvertedIndex + std::marker::Send + std::marker::Sync + 'static> InvertedIndexService
    for Server<T>
{
    async fn get(self, _: context::Context, term: String) -> Vec<String> {
        println!("Get {:?}", term);
        self.inverted_index_lock.read().await.get(&term)
    }

    async fn build(self, _: context::Context, paths: Vec<String>) {
        println!("Build {:?}", paths);
        let mut inverted_index = self.inverted_index_lock.write().await;
        *inverted_index =
            InvertedIndex::build(paths.into_iter().map(|s| PathBuf::from(s)).collect(), 12);
        println!("Done");
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), 5545);

    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            println!("New channel");
            let server_data = MultiFileThreadedSimpleInvertedIndex::build(
                vec![PathBuf::from(
                    "./data/datasets/aclImdb/train/unsup".to_owned(),
                )],
                12,
            );

            let server = Server {
                inverted_index_lock: Arc::new(RwLock::new(server_data)),
            };

            channel.execute(server.serve())
        })
        // Max 10 channels.
        .buffer_unordered(1)
        .for_each(|_| async {})
        .await;
    // let client =
    //     InvertedIndexServiceClient::new(client::Config::default(), client_transport).spawn();

    // client
    //     .build(
    //         context::current(),
    //         vec!["./data/datasets/aclImdb/train/unsup".to_string()],
    //     )
    //     .await?;

    // let hello = client
    //     .get(context::current(), "manpower".to_string())
    //     .await?;

    // println!("{hello:?}");

    Ok(())
}
